import asyncio
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Callable
import numpy as np
import pandas as pd
from dataclasses import dataclass, asdict
import threading
import time
import warnings
warnings.filterwarnings('ignore')

# Configure logging for monitoring
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

@dataclass
class AlertThreshold:
    """Configuration for alert thresholds."""
    parameter: str
    critical_value: float
    warning_value: float
    operator: str  # 'greater', 'less', 'equal'
    description: str
    enabled: bool = True

@dataclass
class MonitoringAlert:
    """Represents an alert generated by the monitoring system."""
    id: str
    timestamp: datetime
    severity: str  # 'INFO', 'WARNING', 'CRITICAL', 'EMERGENCY'
    title: str
    description: str
    location: Dict[str, float]  # {'lat': ..., 'lng': ...}
    parameters: Dict[str, float]
    recommended_actions: List[str]
    acknowledged: bool = False
    resolved: bool = False

@dataclass
class MonitoringTask:
    """Represents a scheduled monitoring task."""
    id: str
    name: str
    interval_minutes: int
    last_run: Optional[datetime]
    next_run: datetime
    enabled: bool
    task_function: Callable
    parameters: Dict

class VegetationMonitoringSystem:
    """
    Automated monitoring system for vegetation detection and wildfire prevention.
    Provides scheduled data updates, real-time alerts, and system health monitoring.
    """
    
    def __init__(self, database_manager=None, weather_service=None, ml_classifier=None):
        self.db_manager = database_manager
        self.weather_service = weather_service
        self.ml_classifier = ml_classifier
        
        # Monitoring state
        self.active_alerts: List[MonitoringAlert] = []
        self.alert_history: List[MonitoringAlert] = []
        self.monitoring_tasks: Dict[str, MonitoringTask] = {}
        self.system_status = {
            'status': 'RUNNING',
            'last_update': datetime.now(),
            'alerts_count': 0,
            'tasks_running': 0,
            'system_health': 'GOOD'
        }
        
        # Default alert thresholds
        self.alert_thresholds = {
            'fire_weather_index': AlertThreshold(
                parameter='fire_weather_index',
                critical_value=75.0,
                warning_value=50.0,
                operator='greater',
                description='Fire Weather Index indicates dangerous conditions',
                enabled=True
            ),
            'vegetation_proximity': AlertThreshold(
                parameter='distance_to_powerline',
                critical_value=5.0,
                warning_value=10.0,
                operator='less',
                description='Vegetation too close to power lines',
                enabled=True
            ),
            'ndvi_growth': AlertThreshold(
                parameter='ndvi_change_rate',
                critical_value=0.3,
                warning_value=0.2,
                operator='greater',
                description='Rapid vegetation growth detected',
                enabled=True
            ),
            'wind_speed': AlertThreshold(
                parameter='wind_speed',
                critical_value=50.0,
                warning_value=35.0,
                operator='greater',
                description='High wind speeds increase fire risk',
                enabled=True
            ),
            'temperature': AlertThreshold(
                parameter='temperature',
                critical_value=40.0,
                warning_value=35.0,
                operator='greater',
                description='Extreme temperature conditions',
                enabled=True
            ),
            'humidity': AlertThreshold(
                parameter='humidity',
                critical_value=20.0,
                warning_value=30.0,
                operator='less',
                description='Low humidity increases fire risk',
                enabled=True
            )
        }
        
        # Initialize default monitoring tasks
        self._initialize_default_tasks()
        
        # Start monitoring system
        self.monitoring_active = False
        self.monitoring_thread = None
        
        # Logger for monitoring system
        self.logger = logging.getLogger('VegetationMonitoring')
        self.logger.info("Vegetation Monitoring System initialized")
    
    def _initialize_default_tasks(self):
        """Initialize default monitoring tasks."""
        self.monitoring_tasks = {
            'weather_update': MonitoringTask(
                id='weather_update',
                name='Weather Data Update',
                interval_minutes=60,  # Every hour
                last_run=None,
                next_run=datetime.now(),
                enabled=True,
                task_function=self._update_weather_data,
                parameters={}
            ),
            'vegetation_analysis': MonitoringTask(
                id='vegetation_analysis',
                name='Vegetation Growth Analysis',
                interval_minutes=360,  # Every 6 hours
                last_run=None,
                next_run=datetime.now() + timedelta(minutes=30),
                enabled=True,
                task_function=self._analyze_vegetation_growth,
                parameters={}
            ),
            'risk_assessment': MonitoringTask(
                id='risk_assessment',
                name='Automated Risk Assessment',
                interval_minutes=180,  # Every 3 hours
                last_run=None,
                next_run=datetime.now() + timedelta(minutes=15),
                enabled=True,
                task_function=self._perform_risk_assessment,
                parameters={}
            ),
            'system_health': MonitoringTask(
                id='system_health',
                name='System Health Check',
                interval_minutes=30,  # Every 30 minutes
                last_run=None,
                next_run=datetime.now() + timedelta(minutes=5),
                enabled=True,
                task_function=self._check_system_health,
                parameters={}
            )
        }
    
    def start_monitoring(self):
        """Start the automated monitoring system."""
        if self.monitoring_active:
            self.logger.warning("Monitoring system is already running")
            return
        
        self.monitoring_active = True
        self.monitoring_thread = threading.Thread(target=self._monitoring_loop, daemon=True)
        self.monitoring_thread.start()
        
        self.logger.info("ðŸš€ Vegetation Monitoring System started")
        self.system_status['status'] = 'RUNNING'
        self.system_status['last_update'] = datetime.now()
    
    def stop_monitoring(self):
        """Stop the automated monitoring system."""
        self.monitoring_active = False
        if self.monitoring_thread:
            self.monitoring_thread.join(timeout=5)
        
        self.logger.info("ðŸ›‘ Vegetation Monitoring System stopped")
        self.system_status['status'] = 'STOPPED'
        self.system_status['last_update'] = datetime.now()
    
    def _monitoring_loop(self):
        """Main monitoring loop that runs scheduled tasks."""
        while self.monitoring_active:
            try:
                current_time = datetime.now()
                
                # Check each monitoring task
                for task_id, task in self.monitoring_tasks.items():
                    if not task.enabled:
                        continue
                    
                    # Check if task should run
                    if current_time >= task.next_run:
                        try:
                            self.logger.info(f"Executing monitoring task: {task.name}")
                            self.system_status['tasks_running'] += 1
                            
                            # Execute the task
                            task.task_function(**task.parameters)
                            
                            # Update task timing
                            task.last_run = current_time
                            task.next_run = current_time + timedelta(minutes=task.interval_minutes)
                            
                            self.system_status['tasks_running'] = max(0, self.system_status['tasks_running'] - 1)
                            self.logger.info(f"Completed monitoring task: {task.name}")
                            
                        except Exception as e:
                            self.logger.error(f"Error executing task {task.name}: {str(e)}")
                            self.system_status['tasks_running'] = max(0, self.system_status['tasks_running'] - 1)
                
                # Update system status
                self.system_status['last_update'] = current_time
                self.system_status['alerts_count'] = len(self.active_alerts)
                
                # Sleep for 30 seconds before next check
                time.sleep(30)
                
            except Exception as e:
                self.logger.error(f"Error in monitoring loop: {str(e)}")
                time.sleep(60)  # Wait longer on error
    
    def _update_weather_data(self):
        """Scheduled task to update weather data for all monitored locations."""
        if not self.weather_service:
            self.logger.warning("Weather service not available")
            return
        
        # Get monitored locations from database or use default
        monitored_locations = self._get_monitored_locations()
        
        for location in monitored_locations:
            try:
                lat, lon = location['lat'], location['lng']
                
                # Get current weather
                current_weather = self.weather_service.get_current_weather(lat, lon)
                fire_index = self.weather_service.calculate_fire_weather_index(current_weather)
                
                # Check for weather-based alerts
                self._check_weather_alerts(location, current_weather, fire_index)
                
                # Store data in database if available
                if self.db_manager:
                    self._store_weather_data(location, current_weather, fire_index)
                
                self.logger.info(f"Updated weather data for location ({lat:.2f}, {lon:.2f})")
                
            except Exception as e:
                self.logger.error(f"Failed to update weather for location {location}: {str(e)}")
    
    def _analyze_vegetation_growth(self):
        """Scheduled task to analyze vegetation growth patterns."""
        monitored_locations = self._get_monitored_locations()
        
        for location in monitored_locations:
            try:
                # Simulate vegetation analysis (would use real satellite data in production)
                growth_data = self._simulate_vegetation_analysis(location)
                
                # Check for vegetation growth alerts
                self._check_vegetation_alerts(location, growth_data)
                
                # Store analysis results
                if self.db_manager:
                    self._store_vegetation_analysis(location, growth_data)
                
                self.logger.info(f"Completed vegetation analysis for location ({location['lat']:.2f}, {location['lng']:.2f})")
                
            except Exception as e:
                self.logger.error(f"Failed vegetation analysis for location {location}: {str(e)}")
    
    def _perform_risk_assessment(self):
        """Scheduled task to perform comprehensive risk assessment."""
        monitored_locations = self._get_monitored_locations()
        
        for location in monitored_locations:
            try:
                # Gather all available data for risk assessment
                risk_factors = self._gather_risk_factors(location)
                
                # Calculate overall risk score
                overall_risk = self._calculate_comprehensive_risk(risk_factors)
                
                # Check for risk-based alerts
                self._check_risk_alerts(location, overall_risk, risk_factors)
                
                # Store risk assessment
                if self.db_manager:
                    self._store_risk_assessment(location, overall_risk, risk_factors)
                
                self.logger.info(f"Completed risk assessment for location ({location['lat']:.2f}, {location['lng']:.2f})")
                
            except Exception as e:
                self.logger.error(f"Failed risk assessment for location {location}: {str(e)}")
    
    def _check_system_health(self):
        """Scheduled task to check overall system health."""
        try:
            health_status = 'GOOD'
            health_issues = []
            
            # Check database connectivity
            if self.db_manager:
                try:
                    # Simple database health check
                    self.db_manager.get_connection()
                except Exception:
                    health_issues.append("Database connection issues")
                    health_status = 'DEGRADED'
            
            # Check active alerts count
            critical_alerts = len([a for a in self.active_alerts if a.severity == 'CRITICAL'])
            if critical_alerts > 5:
                health_issues.append(f"High number of critical alerts: {critical_alerts}")
                health_status = 'DEGRADED'
            
            # Check task execution health
            failed_tasks = 0
            for task in self.monitoring_tasks.values():
                if task.last_run and (datetime.now() - task.last_run).total_seconds() > task.interval_minutes * 60 * 2:
                    failed_tasks += 1
            
            if failed_tasks > 0:
                health_issues.append(f"Tasks not running on schedule: {failed_tasks}")
                health_status = 'DEGRADED'
            
            # Update system health
            self.system_status['system_health'] = health_status
            
            if health_issues:
                self.logger.warning(f"System health issues detected: {', '.join(health_issues)}")
            else:
                self.logger.info("System health check passed")
            
        except Exception as e:
            self.logger.error(f"System health check failed: {str(e)}")
            self.system_status['system_health'] = 'ERROR'
    
    def _get_monitored_locations(self):
        """Get list of locations to monitor."""
        # Default locations (would come from database in production)
        return [
            {'lat': 37.7749, 'lng': -122.4194, 'name': 'San Francisco'},
            {'lat': 34.0522, 'lng': -118.2437, 'name': 'Los Angeles'},
            {'lat': 40.7128, 'lng': -74.0060, 'name': 'New York'}
        ]
    
    def _simulate_vegetation_analysis(self, location):
        """Simulate vegetation analysis for monitoring."""
        # Generate realistic vegetation growth data
        current_ndvi = np.random.normal(0.6, 0.15)
        previous_ndvi = np.random.normal(0.55, 0.15)
        
        return {
            'current_ndvi': float(np.clip(current_ndvi, 0, 1)),
            'previous_ndvi': float(np.clip(previous_ndvi, 0, 1)),
            'ndvi_change_rate': float(current_ndvi - previous_ndvi),
            'vegetation_density': float(np.random.uniform(0.3, 0.9)),
            'canopy_height': float(np.random.normal(10, 5)),
            'distance_to_powerline': float(np.random.uniform(5, 50)),
            'growth_trend': 'increasing' if current_ndvi > previous_ndvi else 'stable'
        }
    
    def _gather_risk_factors(self, location):
        """Gather all available risk factors for a location."""
        # Would gather real data in production
        return {
            'weather_risk': np.random.uniform(20, 80),
            'vegetation_risk': np.random.uniform(10, 70),
            'proximity_risk': np.random.uniform(5, 60),
            'seasonal_risk': np.random.uniform(15, 85),
            'historical_risk': np.random.uniform(10, 50)
        }
    
    def _calculate_comprehensive_risk(self, risk_factors):
        """Calculate overall risk score from multiple factors."""
        weights = {
            'weather_risk': 0.3,
            'vegetation_risk': 0.25,
            'proximity_risk': 0.2,
            'seasonal_risk': 0.15,
            'historical_risk': 0.1
        }
        
        overall_risk = sum(risk_factors[factor] * weight for factor, weight in weights.items())
        return min(100, max(0, overall_risk))
    
    def _check_weather_alerts(self, location, weather_data, fire_index):
        """Check weather data against alert thresholds."""
        parameters = {
            'fire_weather_index': fire_index.get('fire_weather_index', 0),
            'wind_speed': weather_data.get('wind_speed', 0),
            'temperature': weather_data.get('temperature', 20),
            'humidity': weather_data.get('humidity', 50)
        }
        
        for param, value in parameters.items():
            if param in self.alert_thresholds:
                self._evaluate_threshold(location, param, value, 'weather')
    
    def _check_vegetation_alerts(self, location, vegetation_data):
        """Check vegetation data against alert thresholds."""
        parameters = {
            'distance_to_powerline': vegetation_data.get('distance_to_powerline', 50),
            'ndvi_change_rate': abs(vegetation_data.get('ndvi_change_rate', 0))
        }
        
        for param, value in parameters.items():
            if param in self.alert_thresholds:
                self._evaluate_threshold(location, param, value, 'vegetation')
    
    def _check_risk_alerts(self, location, overall_risk, risk_factors):
        """Check overall risk against alert thresholds."""
        if overall_risk > 80:
            self._create_alert(
                location=location,
                severity='CRITICAL',
                title='Critical Fire Risk Detected',
                description=f'Overall fire risk score: {overall_risk:.1f}/100',
                parameters={'overall_risk': overall_risk, **risk_factors},
                recommended_actions=[
                    'Immediate inspection of power line infrastructure',
                    'Deploy emergency response teams',
                    'Consider proactive power shut-offs',
                    'Coordinate with local fire services'
                ]
            )
        elif overall_risk > 60:
            self._create_alert(
                location=location,
                severity='WARNING',
                title='High Fire Risk Alert',
                description=f'Elevated fire risk score: {overall_risk:.1f}/100',
                parameters={'overall_risk': overall_risk, **risk_factors},
                recommended_actions=[
                    'Increase monitoring frequency',
                    'Prepare maintenance crews',
                    'Review vegetation management plans'
                ]
            )
    
    def _evaluate_threshold(self, location, parameter, value, category):
        """Evaluate a parameter against its alert threshold."""
        threshold = self.alert_thresholds.get(parameter)
        if not threshold or not threshold.enabled:
            return
        
        severity = None
        if threshold.operator == 'greater':
            if value >= threshold.critical_value:
                severity = 'CRITICAL'
            elif value >= threshold.warning_value:
                severity = 'WARNING'
        elif threshold.operator == 'less':
            if value <= threshold.critical_value:
                severity = 'CRITICAL'
            elif value <= threshold.warning_value:
                severity = 'WARNING'
        
        if severity:
            self._create_alert(
                location=location,
                severity=severity,
                title=f'{parameter.replace("_", " ").title()} Alert',
                description=f'{threshold.description}: {value:.1f}',
                parameters={parameter: value},
                recommended_actions=self._get_default_recommendations(parameter, severity)
            )
    
    def _create_alert(self, location, severity, title, description, parameters, recommended_actions):
        """Create a new monitoring alert."""
        alert = MonitoringAlert(
            id=f"alert_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{len(self.active_alerts)}",
            timestamp=datetime.now(),
            severity=severity,
            title=title,
            description=description,
            location=location,
            parameters=parameters,
            recommended_actions=recommended_actions
        )
        
        # Check if similar alert already exists
        existing_alert = self._find_similar_alert(alert)
        if existing_alert:
            self.logger.info(f"Similar alert already exists: {existing_alert.id}")
            return
        
        # Add to active alerts
        self.active_alerts.append(alert)
        self.alert_history.append(alert)
        
        self.logger.warning(f"ðŸš¨ {severity} ALERT: {title} at {location.get('name', 'Unknown Location')}")
        
        # Store in database if available
        if self.db_manager:
            self._store_alert(alert)
    
    def _find_similar_alert(self, new_alert):
        """Find if a similar alert already exists."""
        for alert in self.active_alerts:
            if (alert.title == new_alert.title and 
                alert.location == new_alert.location and
                not alert.resolved and
                (new_alert.timestamp - alert.timestamp).total_seconds() < 3600):  # Within 1 hour
                return alert
        return None
    
    def _get_default_recommendations(self, parameter, severity):
        """Get default recommendations for a parameter alert."""
        recommendations = {
            'fire_weather_index': {
                'WARNING': [
                    'Monitor weather conditions closely',
                    'Prepare emergency response teams',
                    'Review fire prevention protocols'
                ],
                'CRITICAL': [
                    'Activate fire weather emergency protocols',
                    'Deploy all monitoring resources',
                    'Consider power system precautions'
                ]
            },
            'distance_to_powerline': {
                'WARNING': [
                    'Schedule vegetation trimming',
                    'Increase inspection frequency',
                    'Monitor growth rate'
                ],
                'CRITICAL': [
                    'Immediate vegetation clearing required',
                    'Emergency maintenance team dispatch',
                    'Consider temporary power adjustments'
                ]
            },
            'wind_speed': {
                'WARNING': [
                    'Monitor power line stability',
                    'Prepare for potential outages',
                    'Alert maintenance crews'
                ],
                'CRITICAL': [
                    'Consider proactive power shut-offs',
                    'Deploy emergency repair teams',
                    'Monitor system integrity continuously'
                ]
            }
        }
        
        return recommendations.get(parameter, {}).get(severity, ['Monitor situation closely'])
    
    def get_monitoring_dashboard_data(self):
        """Get data for monitoring dashboard display."""
        return {
            'system_status': self.system_status,
            'active_alerts': [asdict(alert) for alert in self.active_alerts],
            'recent_alerts': [asdict(alert) for alert in self.alert_history[-10:]],
            'monitoring_tasks': {
                task_id: {
                    'name': task.name,
                    'enabled': task.enabled,
                    'last_run': task.last_run.isoformat() if task.last_run else None,
                    'next_run': task.next_run.isoformat(),
                    'interval_minutes': task.interval_minutes
                }
                for task_id, task in self.monitoring_tasks.items()
            },
            'alert_summary': {
                'critical': len([a for a in self.active_alerts if a.severity == 'CRITICAL']),
                'warning': len([a for a in self.active_alerts if a.severity == 'WARNING']),
                'total_active': len(self.active_alerts),
                'total_today': len([a for a in self.alert_history if a.timestamp.date() == datetime.now().date()])
            }
        }
    
    def acknowledge_alert(self, alert_id):
        """Acknowledge an alert."""
        for alert in self.active_alerts:
            if alert.id == alert_id:
                alert.acknowledged = True
                self.logger.info(f"Alert acknowledged: {alert_id}")
                return True
        return False
    
    def resolve_alert(self, alert_id, resolution_notes=""):
        """Resolve an alert."""
        for alert in self.active_alerts:
            if alert.id == alert_id:
                alert.resolved = True
                alert.acknowledged = True
                self.active_alerts.remove(alert)
                self.logger.info(f"Alert resolved: {alert_id} - {resolution_notes}")
                return True
        return False
    
    def _store_weather_data(self, location, weather_data, fire_index):
        """Store weather data in database."""
        # Would implement database storage in production
        pass
    
    def _store_vegetation_analysis(self, location, vegetation_data):
        """Store vegetation analysis in database."""
        # Would implement database storage in production
        pass
    
    def _store_risk_assessment(self, location, risk_score, risk_factors):
        """Store risk assessment in database."""
        # Would implement database storage in production
        pass
    
    def _store_alert(self, alert):
        """Store alert in database."""
        # Would implement database storage in production
        pass